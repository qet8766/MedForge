#!/usr/bin/env bash
#
# Phase 1 control-plane bootstrap validation.
# Brings up compose services, verifies reachability, and validates seed rows.

set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
PHASE_ID="phase1-bootstrap"
RUN_ID="$(date -u +%Y%m%dT%H%M%SZ)"
EVIDENCE_DIR="${EVIDENCE_DIR:-${ROOT_DIR}/docs/evidence/$(date -u +%F)}"
EVIDENCE_FILE="${EVIDENCE_FILE:-${EVIDENCE_DIR}/${PHASE_ID}-${RUN_ID}.md}"
LOG_FILE="${LOG_FILE:-${EVIDENCE_DIR}/${PHASE_ID}-${RUN_ID}.log}"

ENV_FILE="${ENV_FILE:-${ROOT_DIR}/deploy/compose/.env}"
COMPOSE_FILE="${COMPOSE_FILE:-${ROOT_DIR}/deploy/compose/docker-compose.yml}"
DOMAIN="${DOMAIN:-}"

PHASE_STATUS="INCONCLUSIVE"

usage() {
  cat <<'USAGE'
Usage: bash ops/host/validate-phase1-bootstrap.sh

Optional env:
  ENV_FILE=deploy/compose/.env
  COMPOSE_FILE=deploy/compose/docker-compose.yml
  DOMAIN=<override>
  EVIDENCE_DIR=docs/evidence/<date>
  EVIDENCE_FILE=<explicit markdown path>
  LOG_FILE=<explicit log path>
USAGE
}

read_env_value() {
  local key="$1"
  if [ ! -f "${ENV_FILE}" ]; then
    return 0
  fi
  awk -F= -v k="${key}" '$1 == k {print substr($0, index($0, "=") + 1); exit}' "${ENV_FILE}"
}

require_cmd() {
  local cmd="$1"
  if ! command -v "${cmd}" >/dev/null 2>&1; then
    echo "ERROR: required command not found: ${cmd}"
    exit 1
  fi
}

record() {
  local line="$1"
  printf "%s\n" "${line}" >>"${EVIDENCE_FILE}"
}

run_check() {
  local name="$1"
  local cmd="$2"

  record "### ${name}"
  record ""
  record '```bash'
  record "${cmd}"
  record '```'

  if eval "${cmd}" >>"${LOG_FILE}" 2>&1; then
    record "- status: PASS"
  else
    record "- status: FAIL"
    record "- log: \`${LOG_FILE}\`"
    exit 1
  fi
  record ""
}

wait_for_health() {
  local name="$1"
  local max_attempts="$2"
  local sleep_seconds="$3"
  local checker="$4"
  local attempt=1

  while [ "${attempt}" -le "${max_attempts}" ]; do
    if "${checker}"; then
      echo "${name} ready on attempt ${attempt}/${max_attempts}"
      return 0
    fi
    sleep "${sleep_seconds}"
    attempt=$((attempt + 1))
  done

  echo "ERROR: ${name} not ready after ${max_attempts} attempts"
  return 1
}

cleanup() {
  local exit_code=$?
  if [ "${PHASE_STATUS}" != "PASS" ] && [ -f "${EVIDENCE_FILE}" ]; then
    record "## Verdict"
    record "- phase: \`${PHASE_ID}\`"
    record "- status: FAIL"
    record "- log: \`${LOG_FILE}\`"
  fi
  exit "${exit_code}"
}
trap cleanup EXIT

compose_up() {
  docker compose --env-file "${ENV_FILE}" -f "${COMPOSE_FILE}" up -d --build
}

compose_ps() {
  docker compose --env-file "${ENV_FILE}" -f "${COMPOSE_FILE}" ps
}

services_running() {
  local service
  for service in medforge-db medforge-api medforge-api-worker medforge-web medforge-caddy; do
    docker ps --format '{{.Names}}' | rg -x "${service}" >/dev/null
  done
}

api_health_inside_container() {
  docker exec medforge-api python - <<'PY'
from urllib.request import urlopen

with urlopen("http://127.0.0.1:8000/healthz", timeout=10) as response:
    if response.status != 200:
        raise SystemExit(f"unexpected status: {response.status}")
print("api health ok")
PY
}

web_health_inside_container() {
  docker exec medforge-web node -e '
const http = require("http");
const req = http.get("http://127.0.0.1:3000", (res) => {
  if (res.statusCode >= 200 && res.statusCode < 500) {
    process.exit(0);
  }
  process.exit(1);
});
req.on("error", () => process.exit(1));
setTimeout(() => process.exit(1), 10000);
'
}

db_seed_invariants() {
  local gpu_count
  local pack_count

  gpu_count="$(docker exec medforge-db sh -lc 'mariadb -uroot -p"$MARIADB_ROOT_PASSWORD" -Nse "SELECT COUNT(*) FROM gpu_devices WHERE enabled=1 AND id BETWEEN 0 AND 6;" medforge')"
  if [ "${gpu_count}" != "7" ]; then
    echo "ERROR: expected 7 enabled gpu_devices rows (0..6), got ${gpu_count}"
    return 1
  fi

  pack_count="$(docker exec medforge-db sh -lc 'mariadb -uroot -p"$MARIADB_ROOT_PASSWORD" -Nse "SELECT COUNT(*) FROM packs WHERE image_ref LIKE \"%@sha256:%\" OR image_digest LIKE \"sha256:%\";" medforge')"
  if ! [[ "${pack_count}" =~ ^[0-9]+$ ]] || [ "${pack_count}" -lt 1 ]; then
    echo "ERROR: expected at least one digest-pinned pack"
    return 1
  fi

  echo "gpu_count=${gpu_count}"
  echo "pack_count=${pack_count}"
}

main() {
  if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
    usage
    exit 0
  fi

  require_cmd docker
  require_cmd rg

  if [ ! -f "${ENV_FILE}" ]; then
    echo "ERROR: env file not found: ${ENV_FILE}"
    exit 1
  fi
  if [ ! -f "${COMPOSE_FILE}" ]; then
    echo "ERROR: compose file not found: ${COMPOSE_FILE}"
    exit 1
  fi

  if [ -z "${DOMAIN}" ]; then
    DOMAIN="$(read_env_value DOMAIN)"
  fi

  mkdir -p "${EVIDENCE_DIR}"
  : >"${LOG_FILE}"

  {
    echo "## Phase 1 Control Plane Bootstrap Evidence ($(date -u +%F))"
    echo ""
    echo "Generated by: \`ops/host/validate-phase1-bootstrap.sh\`"
    echo ""
    echo "Runtime:"
    echo "- env file: \`${ENV_FILE}\`"
    echo "- compose file: \`${COMPOSE_FILE}\`"
    echo "- domain: \`${DOMAIN:-unknown}\`"
    echo "- run id: \`${RUN_ID}\`"
    echo ""
  } >"${EVIDENCE_FILE}"

  run_check "Compose Up" "compose_up"
  run_check "Compose Service Table" "compose_ps"
  run_check "Core Services Running" "services_running"
  run_check "API Reachability" "wait_for_health api 30 1 api_health_inside_container"
  run_check "Web Reachability" "wait_for_health web 60 1 web_health_inside_container"
  run_check "Database Seed Invariants" "db_seed_invariants"

  PHASE_STATUS="PASS"
  record "## Verdict"
  record "- phase: \`${PHASE_ID}\`"
  record "- status: PASS"
  record "- log: \`${LOG_FILE}\`"

  echo "Validation complete: ${EVIDENCE_FILE}"
}

main "$@"
